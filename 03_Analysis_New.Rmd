---
title: "Attitudes toward Redistribution"
output:
  html_document:
    df_print: paged
---

TO DO:

? - It cannot be that there is only one wave of Netherlands data, something is wrong with our data compile
? - Two countries still missing GDP, fill in 

Nate - get newer measure of socx from OECD, other macro-level variables (GDP in particular)


##### ISSP, Social Inequality, Cumulation (1987, 1992, 1999, 2009 & 2019)

$~$
$~$

#### **Nate Breznau, Lisa Heukamp, Hung H.V. Nguyen, Tom Knuf, Arne Köller, Sören Goldenstein**
#### **University of Bremen**

_____________________________________________________________________________

$~$
$~$

Working paper available here: https://docs.google.com/document/d/1mST25rKYZ5wChRj5WyhxH_65RUa9MNR2OsO5B4-qcwY/edit#

Github repo: https://github.com/hungnguyen167/Social-Status



```{r, include = F}
rm(list = ls())
```


```{r setup, include=FALSE}
library(pacman)
pacman::p_load("tidyverse", "ggpubr", "ragg", "kableExtra", "lme4", "sjPlot")

knitr::opts_chunk$set(message = F, warning = F)

```


```{r load dfs}
df <- readRDS(here::here("data","df.RDS"))
df_na <- readRDS(here::here("data", "df_na.RDS"))

# The variables names are not intuitive, change them
df <- df %>%
  rename(gov_redist = reduce, incdiff_large = reduce_large)

df_na <- df_na %>%
  rename(gov_redist = reduce, incdiff_large = reduce_large)
```



## Descriptives

### Table 1. Cases by Country-Wave

```{r tbl1, include = T, echo = T}
# Cross-tab years and countries
options(knitr.kable.NA = '')
tab1 <- df_na %>%
  dplyr::group_by(country, wave) %>%
  dplyr::summarize(n=n()) %>%
  spread(wave, n) %>%
  kable(., 
        #col.names = c("Country", "1987", "1992", "1999", "2009", "2019"), 
        caption = "Country Sample Size by Wave, ISSP 'Social Inequality (SI)", format.args = list(big.mark = ","))

kable_styling(tab1)
```
### Table 2. Descriptives w/ Question Wording

```{r}
liberal_redist_label <- "Government should take more responsibility to ensure that everyone is provided for [versus] People should take more responsibility to provide for themselves"
liberal_label <- "Private ownership of business and industry should be increased [versus] government ownership..."
confidence_gov_label <- "I am going to name a number of organizations. For each one, could you tell me how much confidence you have in them: is it a great deal of confidence, quite a lot of confidence, not very much confidence or none at all? [the government]"
democratic_label <- "And how democratically is this country being governed today? Again using a scale from 1 to 10, where 1 means that it is “not at all democratic” and 10 means that it is “completely democratic,” what position would you choose?"
```

## Macro-Correlations


```{r var_dvs}
df_macro <- df_na %>%
  select(iso3c, wave, gov_redist, incdiff_large, gini_disp, gini_mkt, socx, socx_perhead, cpi15_20, liberal, liberal_i, liberal_redist, liberal_redist_i, confidence_gov, confidence_gov_i, democratic, gdp_pc_10k, regime) %>%
  group_by(iso3c, wave) %>%
  summarise_all(mean, na.rm = T) %>%
  ungroup()

df_macro[df_macro == "NaN"] <- NA

df_macro_corr <- df_macro %>%
  select(-c(iso3c, wave)) %>%
  cor(., use = "pairwise.complete.obs") %>%
  as.data.frame() %>%
  round(.,2)
```

### Puzzling correlation check

The positive correlation of liberal_redist and gov_redist is puzzling. Why would a country have more support for people (versus the govt) taking more responsibility to provide for their own needs and agree that the government should reduce income differences?

To investigate we plot the countries, and the result makes clear that this variable cannot be coded correctly. There is no way that the USA is the most supportive of all countries of the government (versus people themselves) taking responsibility for providing for their needs. Yet the WVS codebook suggets that lower values are more support of government.

This is now fixed in the source load for the WVS so re-creating the plot will not reveal the error.

```{r invest_corr}

# df_macro %>%
#   ggplot(aes(y = gov_redist, x = liberal_redist_i)) +
#   geom_label(aes(label = iso3c))

```

### Fig X. Correlation of Redist Variables and Liberal Values by Country-Wave

#### Setup Fig

```{r figx}
# get all correlations

c_corrs = df_na %>% # have to use equal sign here because it is a function
  subset(!is.na(gov_redist) & !is.na(incdiff_large)) %>% # remove missing cases
  group_by(iso3c, wave) %>% # group by country-wave
  mutate(gov_redist_Z = scale(gov_redist),
         incdiff_large_Z = scale(incdiff_large)) %>%
  do(model = lm(gov_redist_Z ~ incdiff_large_Z, data = .)) #run regression for each country

for (j in 1:96) {
c_corrs$corr[j] <- c_corrs[[3]][[j]][["coefficients"]][2]
}

c_corrs <- select(c_corrs, -model)
# merge with df_macro
df_macro <- left_join(df_macro, c_corrs, by = c("iso3c", "wave"))

# for plotting lines of best fit


# first fill in a few missing gdp
df_macro <- df_macro %>%
  group_by(iso3c) %>%
  mutate(gdp_mean = mean(gdp_pc_10k, na.rm = T),
         gdp_i = ifelse(is.na(gdp_pc_10k), gdp_mean, gdp_pc_10k)) %>%
  ungroup()

# create a variable with all values in one, and then split by high and middle income countries
# need to find a way to adjust for economic growth and unblanaced time points for calculating GDP

df_macro <- df_macro %>%
  mutate(liberal_all = ifelse(!is.na(liberal), liberal, liberal_i),
         liberal_high = ifelse(wave < 2009 & gdp_i > 2.5, liberal_all, NA),
         liberal_high = ifelse(wave >= 2009 & gdp_i > 3.3, liberal_all, liberal_high),
         liberal_high = ifelse(iso3c %in% c("NZL","JPN","DNK","GBR","CHE","AUT", "FIN","DEU"), liberal_all, liberal_high), # selection criteria performs poorly, do rest by hand here
         liberal_low = ifelse(is.na(liberal_high), liberal_all, NA),
         liberal_low = ifelse(iso3c %in% c("HRV","CYP","ITA","SVN","CZE"), NA, liberal_low)) # remove some questionable cases



```

#### Plot

```{r figx2}
df_macro %>%
  ggplot() +
  geom_text(aes(y = corr, x = liberal, label = iso3c), color = "black", size = 3) +
  geom_text(aes(y = corr, x = liberal_i, label = iso3c), color = "grey", size = 2) +
  geom_smooth(aes(y = corr, x = liberal_all), method = 'lm', se = F, linetype = "dashed", color = "#DCE319FF") +
  geom_smooth(aes(y = corr, x = liberal_high), method = 'lm', se = F, color = "#20A387FF") +
  geom_smooth(aes(y = corr, x = liberal_low), method = 'lm', se = F, color = "midnightblue") +
  labs(x = "Liberal Values, aggregates from WVS\n(government v. individual needs responsibility)",
       y = "Country-Year Correlation, individuals from ISSP:\n'Government should redistribute' with\n'Differences in income are too large'") +
  theme_classic()
```

### Step Two - Variation incdiff/inclarge

```{r twovar_compare}

```

### Theory

After observing the variation in the correlation between inclarge and incdiff by country. We suspect that attitudes toward the role of government are in play. We suspect these come from institutionalized norms. 

Theory: individuals have values or follow norms about how much the government should intervene in the socio-economic affairs of individuals, how much the government should protect against social risks and how much the government (society) should share or redistribute based on need. 

Hypothesis: In countries where the government does less redistribution or has a weaker welfare state, the correlation between perceptions of the income gap and the idea that the government is responsible for doing something about it will be smaller.


Example: In the US the public may perceive a high or undesirable amount of income inequality, but be less likely to agree that the government should do something about it. Whereas in Germany the public may also perceive a high degree of inequality but be more likely to express that the government should do (is responsible) for doing something about it. 

### Multilevel Models
```{r mlms}
M00 <- lmer(reduce ~ 1 + (1 | iso3c), data = df_na)
M00.5 <- lmer(reduce ~ 1 + reduce_large + (1 | iso3c), data = df_na)
M01 <- lmer(reduce ~ 1 + reduce_large + (1 + reduce_large | iso3c), data = df_na)
M02 <- lmer(reduce ~ 1 + reduce_large*socx + (1 + reduce_large | iso3c), data = df_na)
M03 <- lmer(reduce ~ 1 + reduce_large*gini_disp + (1 + reduce_large | iso3c), data = df_na)

tab_model(M00, M00.5, M01, M02, M03, show.ci = F, p.style = "stars")

```

### Plot SOCX and slope

```{r}

```

