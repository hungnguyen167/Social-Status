---
title: "Attitudes toward Redistribution"
output:
  html_document:
    df_print: paged
---

TO DO:

? - It cannot be that there is only one wave of Netherlands data, something is wrong with our data compile
? - Two countries still missing GDP, fill in 

Nate - get newer measure of socx from OECD, other macro-level variables (GDP in particular)


##### ISSP, Social Inequality, Cumulation (1987, 1992, 1999, 2009 & 2019)

$~$
$~$

#### **Nate Breznau, Lisa Heukamp, Hung H.V. Nguyen, Tom Knuf, Arne Köller, Sören Goldenstein**
#### **University of Bremen**

_____________________________________________________________________________

$~$
$~$

Working paper available here: https://docs.google.com/document/d/1mST25rKYZ5wChRj5WyhxH_65RUa9MNR2OsO5B4-qcwY/edit#

Github repo: https://github.com/hungnguyen167/Social-Status



```{r, include = F}
rm(list = ls())
```


```{r setup, include=FALSE}
library(pacman)
pacman::p_load("tidyverse", "ggpubr", 
               "ragg", "kableExtra", 
               "lme4", 
               "sjPlot",
               "arm",
               "margins",
               "ggeffects")

knitr::opts_chunk$set(message = F, warning = F)

```


```{r load dfs}
df <- readRDS(here::here("data","df.RDS"))
df_na <- readRDS(here::here("data", "df_na.RDS"))
df_macro <- readRDS(here::here("data", "df_macro.RDS"))

```


## Descriptives

### Table 1. Cases by Country-Wave

```{r tbl1, include = T, echo = T}
# Cross-tab years and countries
options(knitr.kable.NA = '')
tab1 <- df_na %>%
  dplyr::group_by(country, wave) %>%
  dplyr::summarize(n=n()) %>%
  spread(wave, n) %>%
  kable(., 
        #col.names = c("Country", "1987", "1992", "1999", "2009", "2019"), 
        caption = "Country Sample Size by Wave, ISSP 'Social Inequality (SI)", format.args = list(big.mark = ","))

kable_styling(tab1)
```
### Table 2. Descriptives w/ Question Wording

```{r}
liberal_redist_label <- "Government should take more responsibility to ensure that everyone is provided for [versus] People should take more responsibility to provide for themselves"
liberal_label <- "Private ownership of business and industry should be increased [versus] government ownership..."
confidence_gov_label <- "I am going to name a number of organizations. For each one, could you tell me how much confidence you have in them: is it a great deal of confidence, quite a lot of confidence, not very much confidence or none at all? [the government]"
democratic_label <- "And how democratically is this country being governed today? Again using a scale from 1 to 10, where 1 means that it is “not at all democratic” and 10 means that it is “completely democratic,” what position would you choose?"
```

## Macro-Correlations


```{r var_dvs}
# create a variable that captures the percentage of respondents that think income gap is too large but do not agree gov should do something about it


df_macro_corr <- df_macro %>%
  dplyr::select(-c(iso3c, wave)) %>%
  cor(., use = "pairwise.complete.obs") %>%
  as.data.frame() %>%
  round(.,2)
```

### Puzzling correlation check

The positive correlation of liberal_redist and gov_redist is puzzling. Why would a country have more support for people (versus the govt) taking more responsibility to provide for their own needs and agree that the government should reduce income differences?

To investigate we plot the countries, and the result makes clear that this variable cannot be coded correctly. There is no way that the USA is the most supportive of all countries of the government (versus people themselves) taking responsibility for providing for their needs. Yet the WVS codebook suggets that lower values are more support of government.

This is now fixed in the source load for the WVS so re-creating the plot will not reveal the error.

```{r invest_corr}

# df_macro %>%
#   ggplot(aes(y = gov_redist, x = liberal_redist_i)) +
#   geom_label(aes(label = iso3c))

```

### Fig X. Correlation of Redist Variables and Context Vars

After observing the variation in the correlation between inclarge and incdiff by country. We suspect that attitudes toward the role of government are in play. We suspect these come from institutionalized norms. 

Theory: individuals have values or follow norms about how much the government should intervene in the socio-economic affairs of individuals, how much the government should protect against social risks and how much the government (society) should share or redistribute based on need. 

Hypothesis: In countries where the government does less redistribution or has a weaker welfare state, the correlation between perceptions of the income gap and the idea that the government is responsible for doing something about it will be smaller.

#### Setup Fig

```{r figx}
# get all correlations

c_corrs = df_na %>% # have to use equal sign here because it is a function
  subset(!is.na(gov_redist) & !is.na(incdiff_large)) %>% # remove missing cases
  group_by(iso3c, wave) %>% # group by country-wave
  mutate(gov_redist_Z = scale(gov_redist),
         incdiff_large_Z = scale(incdiff_large)) %>%
  do(model = lm(gov_redist_Z ~ incdiff_large_Z, data = .)) #run regression for each country

for (j in 1:96) {
c_corrs$corr[j] <- c_corrs[[3]][[j]][["coefficients"]][2]
}

c_corrs <- dplyr::select(c_corrs, -model)
# merge with df_macro
df_macro <- left_join(df_macro, c_corrs, by = c("iso3c", "wave"))

# for plotting lines of best fit


# first fill in a few missing gdp
df_macro <- df_macro %>%
  group_by(iso3c) %>%
  mutate(gdp_mean = mean(gdp_pc_10k, na.rm = T),
         gdp_i = ifelse(is.na(gdp_pc_10k), gdp_mean, gdp_pc_10k)) %>%
  ungroup()

# create a variable with all values in one, and then split by high and middle income countries
# need to find a way to adjust for economic growth and unblanaced time points for calculating GDP

df_macro <- df_macro %>%
  mutate(liberal_all = ifelse(!is.na(liberal), liberal, liberal_i),
         liberal_high = ifelse(wave < 2009 & gdp_i > 2.5, liberal_all, NA),
         liberal_high = ifelse(wave >= 2009 & gdp_i > 3.3, liberal_all, liberal_high),
         liberal_high = ifelse(iso3c %in% c("NZL","JPN","DNK","GBR","CHE","AUT", "FIN","DEU"), liberal_all, liberal_high), # selection criteria performs poorly, do rest by hand here
         liberal_low = ifelse(is.na(liberal_high), liberal_all, NA),
         liberal_low = ifelse(iso3c %in% c("HRV","CYP","ITA","SVN","CZE"), NA, liberal_low)) # remove some questionable cases

# for plotting corruption, generate small variation in CPI for years prior to 2015
#make a predicted confidence_gov variable
m_conf <- lm(confidence_gov_i ~ gdp_pc_10k + socx + cpi15_20, data = df_macro)

df_macro$confidence_gov_i_lm <- predict.lm(m_conf, newdata = df_macro)

df_macro <- df_macro %>%
  mutate(cpi15_20 = ifelse(iso3c == "DNK", 90, cpi15_20),
         confidence_gov_i_i = ifelse(is.na(confidence_gov), confidence_gov_i_lm, confidence_gov_i))

# make small disturbances to the cpi using the confidence in gov within-country variance
df_macro <- df_macro %>%
  mutate(cpi15_20_x = (cpi15_20*confidence_gov_i_i)/2)

m_cpi <- lm(cpi15_20_x ~ factor(iso3c) + confidence_gov_i_i, data = df_macro)

df_macro$cpi15_20_ix <- predict.lm(m_cpi, newdata = df_macro)

m_cpi2 <- lm(cpi15_20 ~ cpi15_20_x, data = df_macro)

df_macro$cpi15_20_ixx <- predict.lm(m_cpi2, newdata = df_macro)

df_macro <- df_macro %>%
  mutate(cpi15_20_i = ifelse(!is.na(cpi15_20), cpi15_20, cpi15_20_ixx),
         cpiZ_i = -1*as.numeric(scale(cpi15_20_i)), # make higher scores = more corrupt percept
         cpiZ = -1*as.numeric(scale(cpi15_20)),
         libZ_i = as.numeric(scale(liberal_redist_i)),
         libZ = as.numeric(scale(liberal_redist)),
         noconf_govZ_i = -1*as.numeric(scale(confidence_gov_i_i)),
         noconf_govZ = -1*as.numeric(scale(confidence_gov)))

# make high and low corruption perceptions and noconf
df_macro <- df_macro %>%
  mutate(noconf_govZ_i = ifelse(noconf_govZ_i < -2, -2, noconf_govZ_i), # two far outliers
         noconf_govZ_i = ifelse(noconf_govZ_i > 2, 2, noconf_govZ_i),
         noconf_govZ = ifelse(noconf_govZ < -2, -2, noconf_govZ),
         noconf_govZ = ifelse(noconf_govZ > 2, 2, noconf_govZ),
         cpi_low = ifelse(!is.na(liberal_low), cpiZ, NA),
         cpi_high = ifelse(!is.na(liberal_high), cpiZ, NA),
         noconf_govZ_low = ifelse(!is.na(liberal_low), noconf_govZ, NA),
         noconf_govZ_hi = ifelse(!is.na(liberal_high), noconf_govZ, NA),
         gdp_lo = ifelse(!is.na(liberal_low), gdp_pc_10k, NA),
         gdp_hi = ifelse(!is.na(liberal_high), gdp_pc_10k, NA)) %>%
  dplyr::select(iso3c, wave, gov_redist, incdiff_large, corr, gini_disp, gini_mkt, socx, gdp_pc_10k, pct_fb_i, liberal, liberal_i, liberal_high, liberal_low, liberal_all, cpi_high, cpi_low, noconf_govZ_low, noconf_govZ_hi, gdp_lo, gdp_hi, liberal_redist, liberal_redist_i, confidence_gov, confidence_gov_i_i, cpi15_20, cpi15_20_i, noconf_govZ, noconf_govZ_i, cpiZ, cpiZ_i, libZ, libZ_i)

# add variance objects, defunkt
cpiZ_var <- as.numeric(var(df_macro$cpiZ, na.rm = T))
confidence_gov_var <- var(df_macro$noconf_govZ, na.rm = T)
liberal_redist_var <- var(df_macro$libZ, na.rm = T)
dv_var <- var(df_na$gov_redist, na.rm = T)

# create within and between values
df_na <- df_na %>%
  group_by(iso3c,wave) %>%
  mutate(incdiff_large_b = mean(incdiff_large, na.rm = T)) %>%
  ungroup()

df_na <- df_na %>%
  mutate(incdiff_large_w = incdiff_large - incdiff_large_b,
         iso3c_wave = paste(iso3c,wave, sep = "_"))

```


```{r prep_data}
df_na <- df_na %>%
  dplyr::select(-c(gini_disp, socx)) 

df_macro <- as.data.frame(df_macro)

df_macro_m <- df_macro %>%
  dplyr::select(iso3c, wave, cpiZ, cpiZ_i, libZ, libZ_i, gdp_pc_10k, gini_disp, socx, noconf_govZ, noconf_govZ_i)

df_na <- df_na %>%
  left_join(df_macro_m, by = c("iso3c", "wave"))
```
#### Plot Liberal Corr

```{r figx2}
#agg_png(here::here("results","Fig2.png"), res = 144, height = 800, width = 1000)
Fig2.1 <- df_macro %>%
  ggplot() +
  geom_text(aes(y = corr, x = liberal, label = iso3c), color = "black", size = 3) +
  geom_text(aes(y = corr, x = liberal_i, label = iso3c), color = "grey", size = 2) +
  geom_smooth(aes(y = corr, x = liberal_all), method = 'lm', se = F, linetype = "dashed", color = "#B8DE29FF") +
  geom_smooth(aes(y = corr, x = liberal_high), method = 'lm', se = F, color = "#20A387FF") +
  geom_smooth(aes(y = corr, x = liberal_low), method = 'lm', se = F, color = "midnightblue") +
  # geom_segment(aes(x = 6.8, xend = 7.2, y = 0.3, yend = 0.3), linetype = "dashed", color = "#B8DE29FF", size = 1.1) +
  # geom_segment(aes(x = 6.8, xend = 7.2, y = 0.26, yend = 0.26), color = "#20A387FF", size = 1.1) +
  # geom_segment(aes(x = 6.8, xend = 7.2, y = 0.22, yend = 0.22), color = "midnightblue", size = 1.1) +
  # annotate(geom = "text", x = 6.8, y = 0.34, label = "Fitted Lines", hjust = 0) +
  # annotate(geom = "text", x = 7.3, y = 0.3, label = "Pooled", hjust = 0, size = 3) +
  # annotate(geom = "text", x = 7.3, y = 0.26, label = "Higher GDP", hjust = 0, size = 3) +
  # annotate(geom = "text", x = 7.3, y = 0.22, label = "Lower GDP", hjust = 0, size = 3) +
  labs(x = "LIBERAL VALUES\nWorld Values Survey data\ngovernment v. individual responsible for needs",
       y = "CORRELATION within COUNTRY-YEAR\n'Government should redistribute' with\n'Differences in income are too large'",
       caption = " \n \n \n ") +
  theme_classic()
#dev.off()

#knitr::include_graphics(here::here("results","Fig2.png"))
```



#### Plot Corrupt / Corr

```{r figx3}
#agg_png(here::here("results","Fig3.png"), res = 144, height = 800, width = 1000)
Fig2.2 <- df_macro %>%
  ggplot() +
  geom_text(aes(y = corr, x = cpiZ, label = iso3c), color = "black", size = 3) +
  geom_smooth(aes(y = corr, x = cpiZ), method = 'lm', se = F, linetype = "dashed", color = "#B8DE29FF") +
  geom_smooth(aes(y = corr, x = cpi_high), method = 'lm', se = F, color = "#20A387FF") +
  geom_smooth(aes(y = corr, x = cpi_low), method = 'lm', se = F, color = "midnightblue") +
  geom_segment(aes(x = -2, xend = -1.7, y = 0.3, yend = 0.3), linetype = "dashed", color = "#B8DE29FF", size = 1.1) +
  geom_segment(aes(x = -2, xend = -1.7, y = 0.26, yend = 0.26), color = "#20A387FF", size = 1.1) +
  geom_segment(aes(x = -2, xend = -1.7, y = 0.22, yend = 0.22), color = "midnightblue", size = 1.1) +
  annotate(geom = "text", x = -2, y = 0.34, label = "Fitted Lines", hjust = 0) +
  annotate(geom = "text", x = -1.6, y = 0.3, label = "Pooled", hjust = 0, size = 3) +
  annotate(geom = "text", x = -1.6, y = 0.26, label = "Higher GDP", hjust = 0, size = 3) +
  annotate(geom = "text", x = -1.6, y = 0.22, label = "Lower GDP", hjust = 0, size = 3) +
  labs(x = "CORRUPTION PERCEPTIONS INDEX (CPI)\nTransparency International data\n ",
       y = "",
       caption = " \nY data from International Social Survey Program\ngrey countries in left-panel interpolated with country-means\nwithin-country CPI disturbance generated by authors") +
  theme_classic()

```

```{r figx3}
#agg_png(here::here("results","Fig3.png"), res = 144, height = 800, width = 1000)
Fig2.3 <- df_macro %>%
  ggplot() +
  geom_text(aes(y = corr, x = noconf_govZ, label = iso3c), color = "black", size = 3) +
  geom_smooth(aes(y = corr, x = noconf_govZ), method = 'lm', se = F, linetype = "dashed", color = "#B8DE29FF") +
  geom_smooth(aes(y = corr, x = noconf_govZ_hi), method = 'lm', se = F, color = "#20A387FF") +
  geom_smooth(aes(y = corr, x = noconf_govZ_low), method = 'lm', se = F, color = "midnightblue") +
  labs(x = "LACK OF TRUST IN GOV\nWorld Values Survey Data\n ",
       y = "",
       caption = " \nY data from International Social Survey Program\ngrey countries in left-panel interpolated with country-means\nwithin-country CPI disturbance generated by authors") +
  theme_classic()

```

```{r figx4}
#agg_png(here::here("results","Fig3.png"), res = 144, height = 800, width = 1000)
Fig2.4 <- df_macro %>%
  ggplot() +
  geom_text(aes(y = corr, x = gdp_pc_10k, label = iso3c), color = "black", size = 3) +
  geom_smooth(aes(y = corr, x = gdp_pc_10k), method = 'lm', se = F, linetype = "dashed", color = "#B8DE29FF") +
  geom_smooth(aes(y = corr, x = gdp_hi), method = 'lm', se = F, color = "#20A387FF") +
  geom_smooth(aes(y = corr, x = gdp_lo), method = 'lm', se = F, color = "midnightblue") +
  geom_segment(aes(x = -2, xend = -1.7, y = 0.3, yend = 0.3), linetype = "dashed", color = "#B8DE29FF", size = 1.1) +
  geom_segment(aes(x = -2, xend = -1.7, y = 0.26, yend = 0.26), color = "#20A387FF", size = 1.1) +
  geom_segment(aes(x = -2, xend = -1.7, y = 0.22, yend = 0.22), color = "midnightblue", size = 1.1) +
  annotate(geom = "text", x = -2, y = 0.34, label = "Fitted Lines", hjust = 0) +
  annotate(geom = "text", x = -1.6, y = 0.3, label = "Pooled", hjust = 0, size = 3) +
  annotate(geom = "text", x = -1.6, y = 0.26, label = "Higher GDP", hjust = 0, size = 3) +
  annotate(geom = "text", x = -1.6, y = 0.22, label = "Lower GDP", hjust = 0, size = 3) +
  labs(x = "GDP PER CAPITA (10k)\nVarieties of Democracy Data\n ",
       y = "",
       caption = " \nY data from International Social Survey Program\ngrey countries in left-panel interpolated with country-means\nwithin-country CPI disturbance generated by authors") +
  theme_classic()

```
### Plot Arranged Figure

```{r fig2}
agg_png(filename = here::here("results","Fig2.png"), res = 144, width = 1500, height = 800)
ggarrange(Fig2.1, Fig2.2, widths = c(1,1.15))
dev.off()

knitr::include_graphics(here::here("results","Fig2.png"))
```
```{r fig3}
agg_png(filename = here::here("results","Fig3.png"), res = 144, width = 1500, height = 800)
ggarrange(Fig2.3, Fig2.4, widths = c(1,1.15))
dev.off()

knitr::include_graphics(here::here("results","Fig3.png"))
```

### Moderation Models

This is a cross-level interaction as macro moderator affects the micro association.

Create a wrapper for lmer models
mod_models - creates tables
loop - creates matrix of results
```{r}
mod_models <- function(df, dv, main_iv, value_var, return_mod=FALSE, ...) {
    df_new <- df %>%
          select(iso3c, wave, dv, main_iv, value_var)
   
    ## baseline model
    m00 <- lmer(get(dv) ~  1 + get(main_iv)+ (1 | iso3c) + (1 | wave), data = df_new)
    # with main effects
    m01 <- lmer(get(dv) ~  1 + get(main_iv) + get(value_var) + (1 | iso3c) + (1 | wave), data = df_new) 
    # random-slopes
    m02 <- lmer(get(dv) ~  1 + get(main_iv) + get(value_var) + (1 | iso3c) + (get(main_iv) | wave), 
                data = df_new)
    # moderation
    m03 <- lmer(get(dv) ~  1 + get(main_iv) + get(value_var) + get(value_var)*get(main_iv)  + 
                  (1 | iso3c) + (1 | wave), data = df_new) 

    if (return_mod == TRUE ) {
        return(m01,m02,m03)
    }

    else {
        tab_temp <- tab_model(m00,m01,m02,m03, show.ci = F, show.aic = T, 
                               show.loglik = T, show.icc = T, p.style = "stars")
        return(tab_temp)

    }
        
}


# all models, make sure the model with the MOST variables is last
# using "get(x)" here doesn't work because the variables names are  wrong for postestimation commands, do by hand
```

### All Plausible Models
```{r}
### These do not need to be in the list, they don't have interactions, only for model fit comparison

## Original (no "i")

M2.01 <- lmer(gov_redist ~ incdiff_large + noconf_govZ + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M2.02 <- lmer(gov_redist ~ incdiff_large + cpiZ + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M2.03 <- lmer(gov_redist ~ incdiff_large + libZ + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

## Imputed ("i")

M2.04i <- lmer(gov_redist ~ incdiff_large + noconf_govZ_i + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M2.05i <- lmer(gov_redist ~ incdiff_large + cpiZ_i + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M2.06i <- lmer(gov_redist ~ incdiff_large + libZ_i + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

## Original within/between
M2.07wb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + noconf_govZ + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M2.08wb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + cpiZ + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M2.09wb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + libZ + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

## Imputed within/between

M2.10iwb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + noconf_govZ_i + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M2.11iwb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + cpiZ_i + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M2.12iwb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + libZ_i + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

# random-slope for incdiff_large by country
M3.01 <- lmer(gov_redist ~ incdiff_large + noconf_govZ + (incdiff_large | iso3c) + (1 | iso3c_wave), data = df_na)

M3.02 <- lmer(gov_redist ~ incdiff_large + cpiZ + (incdiff_large | iso3c) + (1 | iso3c_wave), data = df_na)

M3.03 <- lmer(gov_redist ~ incdiff_large + libZ + (incdiff_large | iso3c) + (1 | iso3c_wave), data = df_na)

M3.04i <- lmer(gov_redist ~ incdiff_large + noconf_govZ_i + (incdiff_large | iso3c) + (1 | iso3c_wave), data = df_na)

M3.05i <- lmer(gov_redist ~ incdiff_large + cpiZ_i + (incdiff_large | iso3c) + (1 | iso3c_wave), data = df_na)

M3.05i <- lmer(gov_redist ~ incdiff_large + libZ_i + (incdiff_large | iso3c) + (1 | iso3c_wave), data = df_na)

M3.07wb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + noconf_govZ + (incdiff_large_w | iso3c) + (1 | iso3c_wave), data = df_na)

M3.08wb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + cpiZ + (incdiff_large_w | iso3c) + (1 | iso3c_wave), data = df_na)

M3.09wb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + libZ + (incdiff_large_w | iso3c) + (1 | iso3c_wave), data = df_na)

M3.10iwb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + noconf_govZ_i + (incdiff_large_w | iso3c) + (1 | iso3c_wave), data = df_na)

M3.11iwb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + cpiZ_i + (incdiff_large_w | iso3c) + (1 | iso3c_wave), data = df_na)

M3.12iwb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + libZ_i + (incdiff_large_w | iso3c) + (1 | iso3c_wave), data = df_na)

# interaction models for plotting
M_4.01 <- lmer(gov_redist ~ incdiff_large + noconf_govZ + noconf_govZ*incdiff_large + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_4.02 <- lmer(gov_redist ~ incdiff_large + cpiZ + cpiZ*incdiff_large + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_4.03 <- lmer(gov_redist ~ incdiff_large + libZ + libZ*incdiff_large + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_4.04i <- lmer(gov_redist ~ incdiff_large + noconf_govZ_i + noconf_govZ_i*incdiff_large + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_4.05i <- lmer(gov_redist ~ incdiff_large + cpiZ_i + cpiZ_i*incdiff_large + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_4.06i <- lmer(gov_redist ~ incdiff_large + libZ_i + libZ_i*incdiff_large + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_4.07wb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + noconf_govZ + noconf_govZ*incdiff_large_w + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_4.08wb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + cpiZ + cpiZ*incdiff_large_w + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_4.09wb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + libZ + libZ*incdiff_large_w + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_4.10iwb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + noconf_govZ_i + noconf_govZ_i*incdiff_large_w + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_4.11iwb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + cpiZ_i + cpiZ_i*incdiff_large_w + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_4.12iwb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + libZ_i + libZ_i*incdiff_large_w + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

### socx control

M_5.01 <- lmer(gov_redist ~ incdiff_large + noconf_govZ + noconf_govZ*incdiff_large + socx + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_5.02 <- lmer(gov_redist ~ incdiff_large + cpiZ + cpiZ*incdiff_large + socx + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_5.03 <- lmer(gov_redist ~ incdiff_large + libZ + libZ*incdiff_large + socx + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_5.04i <- lmer(gov_redist ~ incdiff_large + noconf_govZ_i + noconf_govZ_i*incdiff_large + socx + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_5.05i <- lmer(gov_redist ~ incdiff_large + cpiZ_i + cpiZ_i*incdiff_large + socx + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_5.06i <- lmer(gov_redist ~ incdiff_large + libZ_i + libZ_i*incdiff_large + socx + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_5.07wb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + noconf_govZ + noconf_govZ*incdiff_large_w + socx + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_5.08wb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + cpiZ + cpiZ*incdiff_large_w + socx + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_5.09wb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + libZ + libZ*incdiff_large_w + socx + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_5.10iwb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + noconf_govZ_i + noconf_govZ_i*incdiff_large_w + socx + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_5.11iwb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + cpiZ_i + cpiZ_i*incdiff_large_w + socx + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_5.12iwb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + libZ_i + libZ_i*incdiff_large_w + socx + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

## gini

M_6.01 <- lmer(gov_redist ~ incdiff_large + noconf_govZ + noconf_govZ*incdiff_large + gini_disp + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_6.02 <- lmer(gov_redist ~ incdiff_large + cpiZ + cpiZ*incdiff_large + gini_disp + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_6.03 <- lmer(gov_redist ~ incdiff_large + libZ + libZ*incdiff_large + gini_disp + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_6.04i <- lmer(gov_redist ~ incdiff_large + noconf_govZ_i + noconf_govZ_i*incdiff_large + gini_disp + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_6.05i <- lmer(gov_redist ~ incdiff_large + cpiZ_i + cpiZ_i*incdiff_large + gini_disp + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_6.06i <- lmer(gov_redist ~ incdiff_large + libZ_i + libZ_i*incdiff_large + gini_disp + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_6.07wb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + noconf_govZ + noconf_govZ*incdiff_large_w + gini_disp + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_6.08wb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + cpiZ + cpiZ*incdiff_large_w + gini_disp + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_6.09wb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + libZ + libZ*incdiff_large_w + gini_disp + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_6.10iwb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + noconf_govZ_i + noconf_govZ_i*incdiff_large_w + gini_disp + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_6.11iwb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + cpiZ_i + cpiZ_i*incdiff_large_w + gini_disp + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_6.12iwb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + libZ_i + libZ_i*incdiff_large_w + gini_disp + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

# gdp

M_7.01 <- lmer(gov_redist ~ incdiff_large + noconf_govZ + noconf_govZ*incdiff_large + gdp_pc_10k + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_7.02 <- lmer(gov_redist ~ incdiff_large + cpiZ + cpiZ*incdiff_large + gdp_pc_10k + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_7.03 <- lmer(gov_redist ~ incdiff_large + libZ + libZ*incdiff_large + gdp_pc_10k + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_7.04i <- lmer(gov_redist ~ incdiff_large + noconf_govZ_i + noconf_govZ_i*incdiff_large + gdp_pc_10k + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_7.05i <- lmer(gov_redist ~ incdiff_large + cpiZ_i + cpiZ_i*incdiff_large + gdp_pc_10k + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_7.06i <- lmer(gov_redist ~ incdiff_large + libZ_i + libZ_i*incdiff_large + gdp_pc_10k + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_7.07wb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + noconf_govZ + noconf_govZ*incdiff_large_w + gdp_pc_10k + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_7.08wb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + cpiZ + cpiZ*incdiff_large_w + gdp_pc_10k + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_7.09wb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + libZ + libZ*incdiff_large_w + gdp_pc_10k + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_7.10iwb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + noconf_govZ_i + noconf_govZ_i*incdiff_large_w + gdp_pc_10k + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_7.11iwb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + cpiZ_i + cpiZ_i*incdiff_large_w + gdp_pc_10k + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

M_7.12iwb <- lmer(gov_redist ~ incdiff_large_b + incdiff_large_w + libZ_i + libZ_i*incdiff_large_w + gdp_pc_10k + (1 | iso3c) + (1 | iso3c_wave), data = df_na)

model_list <- mget(ls(pattern = "M_"))
```


```{r combine_results}
# all 'fixed' effects, note number of columns has to be changed if new variables are added
df_margins <- as.data.frame(matrix(nrow = 1:length(model_list), ncol = 22))
colnames(df_margins) <- c("Model", "Int", "incdiff_large", "incdiff_large_b", "incdiff_large_w", "mod", "control", "interaction", "Int_se","incdiff_large_se", "incdiff_large_b_se", "incdiff_large_w_se", "mod_se", "control_se", "interaction_se", "main_iv", "coef_lo", "coef_hi", "coef_delta", "coef_se", "coef_lo95", "coef_hi95")

  len <- length(t(sapply(tail(model_list, n=1), fixef)))

for (m in 1:length(model_list)) {
  
  df_x <- as.matrix(t(sapply(model_list[m], fixef)))
  df_xs <- as.matrix(t(sapply(model_list[m], se.fixef)))
  
  # get standardized naming in margins output
  colnames(df_x) <- gsub(".*:.*", "interaction", colnames(df_x))
  colnames(df_x) <- gsub("lib.*|cpi.*|noconf.*", "mod", colnames(df_x))
  colnames(df_x) <- gsub("socx.*|gdp.*|gini.*", "control", colnames(df_x))
  colnames(df_xs) <- gsub(".*:.*", "interaction", colnames(df_xs))
  colnames(df_xs) <- gsub("lib.*|cpi.*|noconf.*", "mod", colnames(df_xs))
  colnames(df_xs) <- gsub("socx.*|gdp.*|gini.*", "control", colnames(df_xs))  
  
  # replace values from margins command in df_margins
df_margins[m, "Int"] <- df_x[1, "(Intercept)"]

if ("incdiff_large" %in%  colnames(df_x)) {
df_margins[m, "incdiff_large"] <- df_x[1, "incdiff_large"]
}

if ("incdiff_large_b" %in% colnames(df_x)) { 
df_margins[m, "incdiff_large_b"] <- df_x[1, "incdiff_large_b"]
}

if ("incdiff_large_w" %in% colnames(df_x) ) {
df_margins[m, "incdiff_large_w"] <- df_x[1, "incdiff_large_w"]
}

df_margins[m, "interaction"] <- df_x[1, "interaction"]

if ("control"  %in%  colnames(df_x)) {
df_margins[m, "control"] <- df_x[1, "control"]
}

df_margins[m, "mod"] <- df_x[1, "mod"]

df_margins[m, "Int_se"] <- df_xs[1, "(Intercept)"]

if ("incdiff_large" %in% colnames(df_xs) ) {
df_margins[m, "incdiff_large_se"] <- df_xs[1, "incdiff_large"]
}

if ("incdiff_large_b" %in% colnames(df_xs) ) { 
df_margins[m, "incdiff_large_b_se"] <- df_xs[1, "incdiff_large_b"]
}

if ("incdiff_large_w" %in% colnames(df_xs) ) {
df_margins[m, "incdiff_large_w_se"] <- df_xs[1, "incdiff_large_w"]
}

df_margins[m, "interaction_se"] <- df_xs[1, "interaction"]

if ("control" %in%  colnames(df_xs) ) {
df_margins[m, "control_se"] <- df_xs[1, "control"]
}

df_margins[m, "mod_se"] <- df_xs[1, "mod"]

df_margins[m, "Model"] <- rownames(df_x)
}

df_margins[2:ncol(df_margins)] <- round(df_margins[2:ncol(df_margins)], 4)

# we should compare with AMEs, they might be very different results
#test <- margins(M_4.1, at = list(incdiff_large = c(3,4),
#                                 noconf_govZ = c(-1,1)))

# get model names to call models instead of list (lists are really hard to work with sometimes)

model_names <- names(model_list)


for (m in 1:length(model_list)) {
j = ifelse(m %in% c(seq(from = 1, to = 100, by = 6)), "noconf_govZ",
    ifelse(m %in% c(seq(from = 2, to = 100, by = 6)), "cpiZ", 
    ifelse(m %in% c(seq(from = 3, to = 100, by = 6)), "libZ",
    ifelse(m %in% c(seq(from = 4, to = 100, by = 6)), "noconf_govZ_i", 
    ifelse(m %in% c(seq(from = 5, to = 100, by = 6)), "cpiZ_i", "libZ_i")))))
  
  mn <- as.name(model_names[m])
  if (grepl("incdiff_large_w", as.character(model_list[[m]]@call[2]), fixed = TRUE)) {
  margs <- ggpredict(get(mn), c("incdiff_large_w", j))
  }
  
  else {
  margs <- ggpredict(get(mn), c("incdiff_large", j))
  }


  # calculate effect of incdiff_large at low and high values of mod
  df_margins[m, "coef_lo"] <- margs[4, "predicted"] - margs[1, "predicted"]
  df_margins[m, "coef_hi"] <- margs[6, "predicted"] - margs[3, "predicted"]
  # calculate range as SE
  # largest possible

  df_margins[m, "coef_delta"] <- df_margins[m, "coef_hi"] - df_margins[m, "coef_lo"]
  df_margins[m, "coef_se"] <- margs[1, "std.error"]
  # use 4* SE under the assumption that two standard errors should not cross the effect, and that this should be true for both coefficients (the standard errors are not that different across the spectrum so just using the first one should be fine)
  df_margins[m, "coef_lo95"] <-  df_margins[m, "coef_delta"] - (4*(margs[m, "std.error"] ))
  df_margins[m, "coef_hi95"] <-  df_margins[m, "coef_delta"] + (4*(margs[m, "std.error"]))
 df_margins[m, "main_iv"] <- j
}



df_margins <- df_margins %>%
  mutate(moderation = "Yes", # only needed if we add in M2/M3 where mod is "no"
         controls = c(rep("None", 12), rep("socx", 12), rep("gini_disp", 12), rep("gdppc10k", 12))) # this command has to be changed by hand when adding new models

# what we want to know is 
# A) is the main effect of the moderator significant?
# B) is the interaction significant
df_margins <- df_margins %>%
  mutate(mod_main_sig = ifelse(abs(mod)/mod_se > 1.96, 1, 0),
         int_sig = ifelse(abs(interaction)/interaction_se > 1.96, 1, 0),
         #var_interact = (interaction_se^2)*43, #sample size is number of countries now
         #marginal_effect_se = sqrt(var_main_iv + var_interact + 2*incdiffB_interB_cov),
  )


```


```{r prepp}
#prep data for spec curve
df_margins <- df_margins %>%
  arrange(main_iv,coef_delta)

df_margins$count <- seq.int(nrow(df_margins))


```

## Specification Curve

```{r fig1_main}
# for plotting a circle
dat = data.frame(x=runif(1), y=runif(1))

#agg_png(filename = here::here("results/Fig1.png"), width = 800, height = 500, res = 144)


df_margins %>%
ggplot() +
  #geom_errorbar(aes(ymin = lb, ymax = ub), color = "thistle1") +
  geom_point(aes(x = count, y = coef_delta), color = "#7570B3", shape = "|", size = 2, show.legend =F) +
  geom_errorbar(aes(x = count, ymin = coef_lo95, ymax = coef_hi95), color = "grey")





#+ 
  geom_point(aes(x = count, y = est_sig_scl, color = sig_group), shape = "|", size = 3) +
  scale_color_manual(values = c("#E6AB02","NA", "#7570B3"), labels = c("Negative","Not sig.","Positive"," ")) +
  #geom_vline(xintercept = 1214, color = "grey", linetype = "dashed") +
  #geom_vline(xintercept = 52, color = "grey", linetype = "dashed") +
  #ylim(-1.8, 1.8) +
  annotate(geom = "text", x = 340, y = 1.45, label = "NEGATIVE (95% CI)", color = "#E6AB02", fontface = "bold", size = 3) +
  annotate(geom = "text", x = 940, y = 1.45, label = "POSITIVE (95% CI)", color = "#7570B3", fontface = "bold", size = 3) +
  annotate(geom = "text", x = 640, y = 1.45, label = "NOT STAT.\nSIGNIFICANT", fontface = "bold", color = "grey55", size = 3) +
  #annotate(geom = "text", x = 680, y = -1.5, label = "grey indicates not sig.\ndifferent from zero", color = "grey55", size = 3) +
  geom_vline(xintercept = -30) +
  annotate(geom = "segment", x = -35, xend = -25, y = -1.1, yend = -1.1, color = "white", size = 2) +
  annotate(geom = "segment", x = -35, xend = -25, y = 1.1, yend = 1.1, color = "white", size = 2) +
  annotate(geom = "segment", x = -38, xend = -22, y = 1.12, yend = 1.18, color = "black", size = 0.5) +
  annotate(geom = "segment", x = -38, xend = -22, y = -1.18, yend = -1.12, color = "black", size = 0.5) +
  labs(color = "Effect at 95% CI", x = "Models Ordered by AME", y = "Average Marginal Effect (AME)") +
  geom_point(aes(x=340, y=-2), data=dat, size=18, shape=1, color="#E6AB02") +
  geom_point(aes(x=640, y=-2), data=dat, size=26, shape=1, color="grey55") +
  geom_point(aes(x=940, y=-2), data=dat, size=14, shape=1, color="#7570B3") +
  annotate("text", x=340, y=-2, label = paste(sig_neg), color="#E6AB02", fontface = "bold") +
  annotate("text", x=640, y=-2, label = paste(ns), color="grey55", fontface = "bold") +
  annotate("text", x=940, y=-2, label = paste(sig_pos), color="#7570B3", fontface = "bold") +
  annotate("text", x=640, y=-1.1, label = "Weighted % of Distribution:", color="grey20", size = 2.5, fontface = 3) +
  annotate("text", x=640, y=0.5, label = "Point Estimates:", color="grey20", size = 2.5, fontface = 3) +
  scale_y_continuous(labels = c("-0.50","-0.05","0.00","0.05","0.50"), breaks = c(-1.75, -1, 0, 1, 1.75), limits = c(-2.6,1.8)) +
  coord_cartesian(xlim = c(-15,1255), clip = "off") +
  scale_x_continuous(expand = c(0,15)) +
  theme_classic() +
  guides(color = guide_legend(override.aes = list(size=7, color=c("#E6AB02","grey55", "#7570B3","NA")))) +
  theme(
    legend.key.size = unit(2,"line"),
    legend.position = "none",
    #axis.title.x = element_blank()
    axis.line.y = element_blank(),
    )
dev.off()

knitr::include_graphics(here::here("results/Fig1.png"))
```

Try three different "value" variables

```{r}

tab_cpi <- mod_models(df_na, "gov_redist", "incdiff_large", "cpiZ", dv.labels = c("M1", "M2", "M3","M4"),
           pred.labels = c("Intercept", "incdiff_large", "cpiZ", "incdiff_large*cpiZ")) ## low level of abstraction
tab_conf <- mod_models(df_na, "gov_redist", "incdiff_large", "noconf_govZ",dv.labels = c("M1", "M2", "M3","M4"),
           pred.labels = c("Intercept", "incdiff_large", "conf", "incdiff_large*conf")) ## medium level of abstraction
tab_lib <- mod_models(df_na, "gov_redist", "incdiff_large", "libZ",dv.labels = c("M1", "M2", "M3","M4"),
           pred.labels = c("Intercept", "incdiff_large", "lib", "incdiff_large*lib")) ## high level of abstraction

```



```{r}

knitr::knit_print(tab_conf)
knitr::knit_print(tab_lib)
knitr::knit_print(tab_cpi)

```

Correlation table of the three value variables

```{r cor_1}
df_libvars <- df_na[,c("cpiZ", "noconf_govZ", "libZ")]
cor_mat <- cor(df_libvars, use = "complete.obs")
round(cor_mat,2)
```
Correlation table of value variables + other control variables

```{r cor_2}
df_cvars <- df_na[,c("cpiZ", "noconf_govZ", "libZ","regime", "socx", "gdp_pc_10k")]
cor_mat_2 <- cor(df_cvars, use = "complete.obs")
round(cor_mat_2, 2)
```


```{r get_coeff}

```


Alternative Models

With macro controls

Bayesian

With 

```{r bayes}

```


### Plot Margins

#### Single case
corruption = -1, 0, 1
incdiff_large = 3

1.41 + incdiff_large*0.58 + cpiZ*-1 + incdiff_large*cpiZ*-0.08

```{r marginal_effects}

marginal_func <- function(moderator,)
marg_df = as.data.frame(matrix(nrow = 5, ncol = 9))
colnames(marg_df) <- c("cpiZ", "incdiff_large_3", "incdiff_large_4", "b_incd", "b_cpiZ", "b_incXc", "marginal_effect_3", "marginal_effect_4", "margin")

marg_df$cpiZ <- c(-1,0,1)
marg_df$incdiff_large_3 <- c(3,3,3)
marg_df$incdiff_large_4 <- c(4,4,4)
marg_df$b_incd <- c(tab_cpi)
marg_df$b_cpiZ <- c(0.32,0.32,0.32)
marg_df$b_incXc <- c(-0.08,-0.08,-0.08)

marg_df <- marg_df %>%
  mutate(marginal_effect_3 = incdiff_large_3*b_incd + cpiZ*b_cpiZ + cpiZ*incdiff_large_3*b_incXc,
         marginal_effect_4 = incdiff_large_4*b_incd + cpiZ*b_cpiZ + cpiZ*incdiff_large_4*b_incXc,
         margin = marginal_effect_4-marginal_effect_3)

```


```{r margin_plot}
marg_df %>%
  ggplot(aes(x = cpiZ, y = margin)) +
  geom_bar(stat = 'identity') +
  labs(x = "Corruption Perceptions, Standardized",
       y = "Statistical Effect of X1 (Inc. Diff's too Large)\non Y (Gov. Should Reduce Inc. Diff's)",
       title = "The Moderating Impact of Percieved Corruption by Country") +
  theme_classic()
```


Colophon

```{r colophon}
sessionInfo()
```